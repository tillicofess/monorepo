---
title: "Next.js MDX 渲染机制解析：SSR 还是 CSR？"
date: "2026-02-09"
author: "Trae Assistant"
---

# Next.js MDX 渲染机制解析：SSR 还是 CSR？

本文将深度解析本博客所使用的 MDX 渲染方案，并明确回答它是 SSR 还是 CSR。

## 结论：是 SSR (RSC)

目前的实现是 **SSR (Server-Side Rendering)**，准确来说是基于 **React Server Components (RSC)** 的服务端渲染。

## 1. 核心证据

在 `app/blog/[slug]/page.tsx` 中，我们使用了 `next-mdx-remote/rsc`：

```typescript
import { MDXRemote } from 'next-mdx-remote/rsc';

export default async function BlogPost({ params }: Props) {
  // ...
  return (
    <article>
      <MDXRemote source={post.content} components={components} />
    </article>
  );
}
```

注意这里的引用路径是 `next-mdx-remote/rsc`。

### 为什么这是 SSR/RSC？

1.  **执行位置**：`BlogPost` 是一个 `async` 组件（Server Component）。
2.  **编译时机**：MDX 的解析和编译完全在**服务端**进行。`MDXRemote` 接收原始的 Markdown 字符串，在服务器上将其转换为 React 元素树。
3.  **传输内容**：发送给浏览器的不是原始 Markdown 文本，也不是巨大的解析器 JS bundle，而是已经渲染好的 HTML 结构（以及少量用于交互组件的序列化数据）。

## 2. 混合渲染模式 (Hybrid)

虽然 MDX 主体是 SSR 的，但我们不仅限于静态内容。通过 `components` 属性，我们将 **客户端组件 (CSR)** 嵌入到了服务端渲染的内容中。

```typescript
const components = {
  Sandpack,           // 'use client' 组件
  PackageManagerTabs, // 'use client' 组件
  pre: Pre,           // 'use client' 组件
};
```

### 工作流原理

1.  **服务端 (Server)**：
    *   读取 `.mdx` 文件。
    *   解析 Markdown 语法。
    *   执行 Rehype 插件（如代码高亮）。
    *   遇到标准 HTML 标签（如 `<p>`, `<h1>`），直接生成对应的 RSC Payload。
    *   遇到自定义组件（如 `<Sandpack>`），在 RSC Payload 中标记"这里需要渲染一个客户端组件"，并传递 props。

2.  **客户端 (Client)**：
    *   接收 RSC Payload。
    *   将静态 HTML 部分直接插入 DOM。
    *   加载 `Sandpack` 等组件的 JavaScript bundle，并进行 Hydration（注水），使其具有交互性。

## 3. 方案优势

| 特性 | 本方案 (RSC) | 传统 CSR (如 React Router) | 传统 SSR (如 Next.js Pages) |
| :--- | :--- | :--- | :--- |
| **首屏速度** | ✅ 极快 (HTML 直出) | ❌ 慢 (需加载 JS 后渲染) | ✅ 快 |
| **JS 体积** | ✅ 极小 (不含 Markdown 解析器) | ❌ 大 (需包含解析器) | ✅ 小 |
| **交互性** | ✅ 支持 (通过 Client Components) | ✅ 支持 | ⚠️ 较难 (需 hydrate 整个页面) |
| **SEO** | ✅ 完美 | ❌ 差 | ✅ 完美 |

## 4. 总结

本博客采用的是目前 Next.js 生态中最先进的 **RSC + MDX** 模式。

*   **文章内容**：在服务端静态化（Static Rendering），保证最佳性能和 SEO。
*   **交互组件**：按需加载客户端 JS，提供丰富的交互体验（如代码编辑器、Tab 切换）。

这种架构完美平衡了**静态内容的性能**与**动态组件的交互能力**。
